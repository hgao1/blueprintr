% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/macros.R
\name{blueprint_macros}
\alias{blueprint_macros}
\alias{.TARGET}
\alias{.BLUEPRINT}
\alias{.META}
\title{Macros for blueprint authoring}
\usage{
.TARGET(bp_name, .env = parent.frame())

.BLUEPRINT(bp_name, .env = parent.frame())

.META(bp_name, .env = parent.frame())
}
\arguments{
\item{bp_name}{Character string of blueprint's name}

\item{.env}{The environment in which to evaluate the macro. For internal
use only!}
}
\description{
\code{blueprintr} uses code inspection to identify and trace dataset dependencies.
These macro functions signal a dependency to \code{blueprintr} and evaluate to
symbols to be analyzed in the \code{drake} plan.
}
\section{Functions}{
\itemize{
\item \code{.TARGET()}: Gets symbol of built and checked data

\item \code{.BLUEPRINT()}: Gets symbol of blueprint reference in plan

\item \code{.META()}: Gets symbol of metadata reference in plan

}}
\section{When to use}{
Generally speaking, the \code{.BLUEPRINT} and \code{.META} macros should be used for
check functions, which frequently require context, e.g. in the form of
configuration from the blueprint or coding expectations from the metadata.
\code{.TARGET} is primarily used in blueprint commands, but there could be
situations where a check depends on the content of another dataset.

It is important to note that the symbols generated by these macros are only
understood in the context of a \code{drake} plan. The targets associated with the
symbols are generated when blueprints are attached to a plan.
}

\examples{
.TARGET("example_dataset")
.BLUEPRINT("example_dataset")
.META("example_dataset")

blueprint(
  "test_bp",
  description = "Blueprint with dependencies",
  command =
    .TARGET("parent1") \%>\%
      left_join(.TARGET("parent2"), by = "id") \%>\%
      filter(!is.na(id))
)
}
