% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/macros.R
\name{blueprint_macros}
\alias{blueprint_macros}
\alias{.TARGET}
\alias{.BLUEPRINT}
\alias{.META}
\alias{.SOURCE}
\alias{mark_source}
\title{Macros for blueprint authoring}
\usage{
.TARGET(bp_name, .env = parent.frame())

.BLUEPRINT(bp_name, .env = parent.frame())

.META(bp_name, .env = parent.frame())

.SOURCE(dat_name)

mark_source(dat)
}
\arguments{
\item{bp_name}{Character string of blueprint's name}

\item{.env}{The environment in which to evaluate the macro. For internal
use only!}

\item{dat_name}{Character string of an object's name, used exclusively
for marking "sources"}

\item{dat}{A data.frame-like object}
}
\description{
\code{blueprintr} uses code inspection to identify and trace dataset dependencies.
These macro functions signal a dependency to \code{blueprintr} and evaluate to
symbols to be analyzed in the \code{drake} plan.
}
\section{Functions}{
\itemize{
\item \code{.TARGET()}: Gets symbol of built and checked data

\item \code{.BLUEPRINT()}: Gets symbol of blueprint reference in plan

\item \code{.META()}: Gets symbol of metadata reference in plan

\item \code{.SOURCE()}: Gets a symbol for an object intended to be a
"data source"

\item \code{mark_source()}: Mark an data.frame-like object as a source table

}}
\section{When to use}{
Generally speaking, the \code{.BLUEPRINT} and \code{.META} macros should be used for
check functions, which frequently require context, e.g. in the form of
configuration from the blueprint or coding expectations from the metadata.
\code{.TARGET} is primarily used in blueprint commands, but there could be
situations where a check depends on the content of another dataset.

It is important to note that the symbols generated by these macros are only
understood in the context of a \code{drake} plan. The targets associated with the
symbols are generated when blueprints are attached to a plan.
}

\section{Sources}{
Sources are an ability to add variable UUIDs to objects that are not constructed
using blueprints. This is often the case if the sourced table derives from some
intermittent HTTP query or a file from disk. Blueprints have limited capability
of configuring the underlying target behavior during the \verb{_initial} phase, so often
it is easier to do that sort of fetching and pre-processing before using blueprints.
However, you lose the benefit of variable lineage when you don't use blueprints.
"Sources" are simply data.frame-like objects that have the ".uuid" attribute for each
variable so that variable lineage can cover the full data lifetime. Use \code{blueprintr::mark_source()}
to add the UUID attributes, and then use \code{.SOURCE()} in the blueprints so lineage
can be captured
}

\examples{
.TARGET("example_dataset")
.BLUEPRINT("example_dataset")
.META("example_dataset")

blueprint(
  "test_bp",
  description = "Blueprint with dependencies",
  command =
    .TARGET("parent1") \%>\%
      left_join(.TARGET("parent2"), by = "id") \%>\%
      filter(!is.na(id))
)
}
